--- a/drivers/hwmon/aspeed2600-pwm-tacho.c	2021-05-16 20:09:07.424160095 +0530
+++ b/drivers/hwmon/aspeed2600-pwm-tacho.c	2021-05-16 20:09:40.068012652 +0530
@@ -22,22 +22,10 @@
 #include <linux/reset.h>
 #include <linux/regmap.h>
 #include <linux/thermal.h>
-/**********************************************************
- * PWM HW register offset define
- *********************************************************/
-//PWM Control Register
-#define ASPEED_PWM_CTRL_CH(ch)			((ch * 0x10) + 0x00)
-//PWM Duty Cycle Register
-#define ASPEED_PWM_DUTY_CYCLE_CH(ch)	((ch * 0x10) + 0x04)
-//TACH Control Register
-#define ASPEED_TACHO_CTRL_CH(ch)		((ch * 0x10) + 0x08)
-//TACH Status Register
-#define ASPEED_TACHO_STS_CH(x)			((x * 0x10) + 0x0C)
-/**********************************************************
- * PWM register Bit field 
- *********************************************************/
-/*PWM_CTRL */
-#define  PWM_LOAD_SEL_AS_WDT_BIT	(19)	//load selection as WDT
+
+#define ASPEED_PWM_CTRL			0x00	//PWM0 General Register
+#define ASPEED_PWM_CTRL_CH(x)		((x * 0x10) + 0x00)
+#define  PWM_LOAD_AS_WDT			BIT(19)	//load selection as WDT
 #define  PWM_DUTY_LOAD_AS_WDT_EN	BIT(18)	//enable PWM duty load as WDT
 #define  PWM_DUTY_SYNC_DIS			BIT(17)	//disable PWM duty sync
 #define	 PWM_CLK_ENABLE				BIT(16)	//enable PWM clock
@@ -47,48 +35,63 @@
 #define  PWM_PIN_EN					BIT(12) //enable PWM pin
 #define  PWM_CLK_DIV_H_MASK			(0xf << 8)	//PWM clock division H bit [3:0]
 #define  PWM_CLK_DIV_L_MASK			(0xff)	//PWM clock division H bit [3:0]
-/* [19] */
-#define LOAD_SEL_FALLING 0
-#define LOAD_SEL_RIGING  1
 
-/*PWM_DUTY_CYCLE */
+/*
+\xregmid {11:8 }{RW}{PWM clock division H bit [3:0]}{
+                     0: divide 1 \n
+                     1: divide 2 \n
+                     2: divide 4 \n
+                     3: divide 8 \n
+                     ... \n
+                     F: divide 32768}
+\xregmid {7 :0 }{RW}{PWM clock division L bit [7:0]}{
+                     00: divide 1 \n
+                     01: divide 2 \n
+                     02: divide 3 \n
+                     03: divide 4 \n
+                     ... \n
+                     FF: divide 256}
+*/
+
+#define ASPEED_PWM_DUTY_CYCLE		0x04	//PWM0 Duty Cycle Register
+#define ASPEED_PWM_DUTY_CYCLE_CH(x)		((x * 0x10) + 0x04)
+#define  PWM_LOOP_BIT_MASK				(0xf << 24)	//loop bit [7:0]
 #define  PWM_PERIOD_BIT					(24)	//pwm period bit [7:0]
 #define  PWM_PERIOD_BIT_MASK			(0xff << 24)	//pwm period bit [7:0]
 #define  PWM_RISING_FALLING_AS_WDT_BIT  (16)	
 #define  PWM_RISING_FALLING_AS_WDT_MASK (0xff << 16)	//pwm rising/falling point bit [7:0] as WDT
 #define  PWM_RISING_FALLING_MASK		(0xffff)	
-#define  PWM_FALLING_POINT_BIT			(8)	//pwm falling point bit [7:0]
-#define  PWM_RISING_POINT_BIT			(0)	//pwm rising point bit [7:0]
-/* [31:24] */
-#define  DEFAULT_PWM_PERIOD 0xff
-
-/*PWM_TACHO_CTRL */
-#define  TACHO_IER						BIT(31)	//enable tacho interrupt
-#define  TACHO_INVERS_LIMIT				BIT(30) //inverse tacho limit comparison
-#define  TACHO_LOOPBACK					BIT(29) //tacho loopback
-#define  TACHO_ENABLE					BIT(28)	//{enable tacho}
-#define  TACHO_DEBOUNCE_MASK			(0x3 << 26) //{tacho de-bounce}
-#define  TACHO_DEBOUNCE_BIT				(26) //{tacho de-bounce}
+#define  PWM_RISING_FALLING_BIT			(8)	//pwm falling point bit [7:0]
+#define  PWM_RISING_RISING_BIT			(0)	//pwm rising point bit [7:0]
+
+#define ASPEED_TECHO_CTRL		0x08	//TACH0 General Register
+#define ASPEED_TECHO_CTRL_CH(x)			((x * 0x10) + 0x08)
+#define  TECHO_IER						BIT(31)	//enable tacho interrupt
+#define  TECHO_INVERS_LIMIT				BIT(30) //inverse tacho limit comparison
+#define  TECHO_LOOPBACK					BIT(29) //tacho loopback
+#define  TECHO_ENABLE					BIT(28)	//{enable tacho}
+#define  TECHO_DEBOUNCE_BIT				(26) //{tacho de-bounce}
+#define  TECHO_DEBOUNCE_MASK			(0x3 << 26) //{tacho de-bounce}
 #define  TECHIO_EDGE_MASK				(0x3 << 24) //tacho edge}
 #define  TECHIO_EDGE_BIT				(24) //tacho edge}
-#define  TACHO_CLK_DIV_T_MASK			(0xf << 20) 
-#define  TACHO_CLK_DIV_BIT				(20)
-#define  TACHO_THRESHOLD_MASK			(0xfffff)	//tacho threshold bit
-/* [27:26] */
-#define DEBOUNCE_3_CLK 0x00 /* 10b */
-#define DEBOUNCE_2_CLK 0x01 /* 10b */
-#define DEBOUNCE_1_CLK 0x02 /* 10b */
-#define DEBOUNCE_0_CLK 0x03 /* 10b */
-/* [25:24] */
-#define F2F_EDGES 0x00 /* 10b */
-#define R2R_EDGES 0x01 /* 10b */
-#define BOTH_EDGES 0x02 /* 10b */
-/* [23:20] */
-/* Cover rpm range 5~5859375 */
-#define  DEFAULT_TACHO_DIV 5
-
-/*PWM_TACHO_STS */
-#define  TACHO_ISR			BIT(31)	//interrupt status and clear
+#define  TECHO_CLK_DIV_T_MASK			(0xf << 20) 
+#define  TECHO_CLK_DIV_BIT				(20)
+#define  TECHO_THRESHOLD_MASK			(0xfffff)	//tacho threshold bit
+/*
+\xregmid {23:20}{RW}{tacho clock division T bit [3:0]}{
+                     0: divide 1 \n
+                     1: divide 4 \n
+                     2: divide 16 \n
+                     3: divide 64 \n
+                     ... \n
+                     B: divide 4194304 \n
+					 others: reserved}
+\xregmidb{19 :0 }{RW}{tacho threshold bit [19:0]}
+*/
+
+#define ASPEED_TECHO_STS		0x0C	//TACH0 Status Register
+#define ASPEED_TECHO_STS_CH(x)			((x * 0x10) + 0x0C)
+#define  TECHO_ISR			BIT(31)	//interrupt status and clear
 #define  PWM_OUT			BIT(25)	//{pwm_out}
 #define  PWM_OEN			BIT(24)	//{pwm_oeN}
 #define  TACHO_DEB_INPUT	BIT(23)	//tacho deB input
@@ -96,326 +99,346 @@
 #define  TACHO_VALUE_UPDATE	BIT(21)	//tacho value updated since the last read
 #define  TACHO_FULL_MEASUREMENT	BIT(20) //{tacho full measurement}
 #define  TACHO_VALUE_MASK	0xfffff	//tacho value bit [19:0]}
-/**********************************************************
- * Software setting
- *********************************************************/
-#define DEFAULT_TARGET_PWM_FREQ		25000
-#define DEFAULT_FAN_PULSE_PR 2
+
 #define MAX_CDEV_NAME_LEN 16
 
 struct aspeed_pwm_channel_params {
-	int target_freq;
-	int pwm_freq;
 	int load_wdt_rising_falling_pt;
 	int load_wdt_selection;		//0: rising , 1: falling
 	int load_wdt_enable;
 	int	duty_sync_enable;
 	int invert_pin;
+	u8	divide_h;
+	u8	divide_l;
+	u8	period;
 	u8	rising;
 	u8	falling;
 };
 
 static struct aspeed_pwm_channel_params default_pwm_params[] = {
 	[0] = {
-		.target_freq = 25000,
 		.load_wdt_rising_falling_pt = 0x10,
-		.load_wdt_selection = LOAD_SEL_FALLING,
-		.load_wdt_enable = 1,
+		.load_wdt_selection = 0,
+		//.load_wdt_enable = 1,
+		.load_wdt_enable = 0,
 		.duty_sync_enable = 0,
 		.invert_pin = 0,
+		.divide_h = 0x3,
+		.divide_l = 0x3,
+		.period = 0xFF,	//100% ~~
 		.rising = 0x00,
-		.falling = 0xc8,
-		
+		.falling = 0x64,
 	},
 	[1] = {
-		.target_freq = 25000,
 		.load_wdt_rising_falling_pt = 0x10,	
-		.load_wdt_selection = LOAD_SEL_FALLING,
+		.load_wdt_selection = 0,
 		.load_wdt_enable = 0,
 		.duty_sync_enable = 0,
 		.invert_pin = 0,
+		.divide_h = 0x3,
+		.divide_l = 0x3,
+		.period = 0xFF,	//100% ~~
 		.rising = 0x00,
-		.falling = 0xc8,
+		.falling = 0x64,
 	},
 	[2] = {
-		.target_freq = 25000,
 		.load_wdt_rising_falling_pt = 0x10,	
-		.load_wdt_selection = LOAD_SEL_FALLING,
+		.load_wdt_selection = 0,
 		.load_wdt_enable = 0,
 		.duty_sync_enable = 0,
 		.invert_pin = 0,
+		.divide_h = 0x3,
+		.divide_l = 0x3,
+		.period = 0xFF,	//100% ~~
 		.rising = 0x00,
-		.falling = 0xc8,
+		.falling = 0x64,
 	},
 	[3] = {
-		.target_freq = 25000,
 		.load_wdt_rising_falling_pt = 0x10,	
-		.load_wdt_selection = LOAD_SEL_FALLING,
+		.load_wdt_selection = 0,
 		.load_wdt_enable = 0,
 		.duty_sync_enable = 0,
 		.invert_pin = 0,
+		.divide_h = 0x3,
+		.divide_l = 0x3,
+		.period = 0xFF,	//100% ~~
 		.rising = 0x00,
-		.falling = 0xc8,
+		.falling = 0x64,
 	},
 	[4] = {
-		.target_freq = 25000,
 		.load_wdt_rising_falling_pt = 0x10,	
-		.load_wdt_selection = LOAD_SEL_FALLING,
+		.load_wdt_selection = 0,
 		.load_wdt_enable = 0,
 		.duty_sync_enable = 0,
 		.invert_pin = 0,
+		.divide_h = 0x3,
+		.divide_l = 0x3,
+		.period = 0xFF,	//100% ~~
 		.rising = 0x00,
-		.falling = 0xc8,
+		.falling = 0x3c,
 	},
 	[5] = {
-		.target_freq = 25000,
 		.load_wdt_rising_falling_pt = 0x10,	
-		.load_wdt_selection = LOAD_SEL_FALLING,
+		.load_wdt_selection = 0,
 		.load_wdt_enable = 0,
 		.duty_sync_enable = 0,
 		.invert_pin = 0,
+		.divide_h = 0x3,
+		.divide_l = 0x3,
+		.period = 0xFF,	//100% ~~
 		.rising = 0x00,
-		.falling = 0xc8,
+		.falling = 0x3c,
 	},
 	[6] = {
-		.target_freq = 25000,
 		.load_wdt_rising_falling_pt = 0x10,	
-		.load_wdt_selection = LOAD_SEL_FALLING,
+		.load_wdt_selection = 0,
 		.load_wdt_enable = 0,
 		.duty_sync_enable = 0,
 		.invert_pin = 0,
+		.divide_h = 0x5,
+		.divide_l = 0x6,
+		.period = 0x13,	//5% ~~
 		.rising = 0x00,
 		.falling = 0x0a,
 	},
 	[7] = {
-		.target_freq = 25000,
 		.load_wdt_rising_falling_pt = 0x10,	
-		.load_wdt_selection = LOAD_SEL_FALLING,
+		.load_wdt_selection = 0,
 		.load_wdt_enable = 0,
 		.duty_sync_enable = 0,
 		.invert_pin = 0,
+		.divide_h = 0x5,
+		.divide_l = 0x6,
+		.period = 0x13,	//5% ~~
 		.rising = 0x00,
 		.falling = 0x0a,
 	},
 	[8] = {
-		.target_freq = 25000,
 		.load_wdt_rising_falling_pt = 0x10,	
-		.load_wdt_selection = LOAD_SEL_FALLING,
+		.load_wdt_selection = 0,
 		.load_wdt_enable = 0,
 		.duty_sync_enable = 0,
 		.invert_pin = 0,
+		.divide_h = 0x5,
+		.divide_l = 0x6,
+		.period = 0x13,	//5% ~~
 		.rising = 0x00,
 		.falling = 0x0a,
 	},
 	[9] = {
-		.target_freq = 25000,
 		.load_wdt_rising_falling_pt = 0x10,	
-		.load_wdt_selection = LOAD_SEL_FALLING,
+		.load_wdt_selection = 0,
 		.load_wdt_enable = 0,
 		.duty_sync_enable = 0,
 		.invert_pin = 0,
+		.divide_h = 0x5,
+		.divide_l = 0x6,
+		.period = 0x13,	//5% ~~
 		.rising = 0x00,
 		.falling = 0x0a,
 	},
 	[10] = {
-		.target_freq = 25000,
 		.load_wdt_rising_falling_pt = 0x10,	
-		.load_wdt_selection = LOAD_SEL_FALLING,
+		.load_wdt_selection = 0,
 		.load_wdt_enable = 0,
 		.duty_sync_enable = 0,
 		.invert_pin = 0,
+		.divide_h = 0x5,
+		.divide_l = 0x6,
+		.period = 0x13,	//5% ~~
 		.rising = 0x00,
 		.falling = 0x0a,
 	},
 	[11] = {
-		.target_freq = 25000,
 		.load_wdt_rising_falling_pt = 0x10,	
-		.load_wdt_selection = LOAD_SEL_FALLING,
+		.load_wdt_selection = 0,
 		.load_wdt_enable = 0,
 		.duty_sync_enable = 0,
 		.invert_pin = 0,
+		.divide_h = 0x5,
+		.divide_l = 0x6,
+		.period = 0x13,	//5% ~~
 		.rising = 0x00,
 		.falling = 0x0a,
 	},
 	[12] = {
-		.target_freq = 25000,
 		.load_wdt_rising_falling_pt = 0x10,	
-		.load_wdt_selection = LOAD_SEL_FALLING,
+		.load_wdt_selection = 0,
 		.load_wdt_enable = 0,
 		.duty_sync_enable = 0,
 		.invert_pin = 0,
+		.divide_h = 0x5,
+		.divide_l = 0x6,
+		.period = 0x13,	//5% ~~
 		.rising = 0x00,
 		.falling = 0x0a,
 	},
 	[13] = {
-		.target_freq = 25000,
 		.load_wdt_rising_falling_pt = 0x10,	
-		.load_wdt_selection = LOAD_SEL_FALLING,
+		.load_wdt_selection = 0,
 		.load_wdt_enable = 0,
 		.duty_sync_enable = 0,
 		.invert_pin = 0,
+		.divide_h = 0x5,
+		.divide_l = 0x6,
+		.period = 0x13,	//5% ~~
 		.rising = 0x00,
 		.falling = 0x0a,
 	},
 	[14] = {
-		.target_freq = 25000,
 		.load_wdt_rising_falling_pt = 0x10,	
-		.load_wdt_selection = LOAD_SEL_FALLING,
+		.load_wdt_selection = 0,
 		.load_wdt_enable = 0,
 		.duty_sync_enable = 0,
 		.invert_pin = 0,
+		.divide_h = 0x5,
+		.divide_l = 0x6,
+		.period = 0x13,	//5% ~~
 		.rising = 0x00,
 		.falling = 0x0a,
 	},
 	[15] = {
-		.target_freq = 25000,
 		.load_wdt_rising_falling_pt = 0x10,	
-		.load_wdt_selection = LOAD_SEL_FALLING,
+		.load_wdt_selection = 0,
 		.load_wdt_enable = 0,
 		.duty_sync_enable = 0,
 		.invert_pin = 0,
+		.divide_h = 0x5,
+		.divide_l = 0x6,
+		.period = 0x13,	//5% ~~
 		.rising = 0x00,
 		.falling = 0x0a,
 	},
 };
 
-struct aspeed_tacho_channel_params {
+/*
+ * 5:4 fan tach edge mode selection bit:
+ * 00: falling
+ * 01: rising
+ * 10: both
+ * 11: reserved.
+ */
+
+struct aspeed_techo_channel_params {
 	int limited_inverse;
 	u16 threshold;
 	u8	tacho_edge;
-	u8	tacho_debounce;
-	u8  pulse_pr;
-	u32	divide;
+	u8	tacho_debounce;	
+	u8	divide;
 };
 
 
-static struct aspeed_tacho_channel_params default_tacho_params[] = {
+static struct aspeed_techo_channel_params default_techo_params[] = {
 	[0] = {
 		.limited_inverse = 0,
 		.threshold = 0,
-		.tacho_edge = F2F_EDGES,
-		.tacho_debounce = DEBOUNCE_3_CLK,
-		.pulse_pr = DEFAULT_FAN_PULSE_PR,
+		.tacho_edge = 0,
+		.tacho_debounce = 0,
 		.divide = 8,
 	},
 	[1] = {
 		.limited_inverse = 0,
 		.threshold = 0,
-		.tacho_edge = F2F_EDGES,
-		.tacho_debounce = DEBOUNCE_3_CLK,
-		.pulse_pr = DEFAULT_FAN_PULSE_PR,		
+		.tacho_edge = 0,
+		.tacho_debounce = 0,		
 		.divide = 8,
 	},
 	[2] = {
 		.limited_inverse = 0,
 		.threshold = 0,
-		.tacho_edge = F2F_EDGES,
-		.tacho_debounce = DEBOUNCE_3_CLK,
-		.pulse_pr = DEFAULT_FAN_PULSE_PR,		
+		.tacho_edge = 0,
+		.tacho_debounce = 0,		
 		.divide = 8,
 	},
 	[3] = {
 		.limited_inverse = 0,
 		.threshold = 0,
-		.tacho_edge = F2F_EDGES,
-		.tacho_debounce = DEBOUNCE_3_CLK,
-		.pulse_pr = DEFAULT_FAN_PULSE_PR,		
+		.tacho_edge = 0,
+		.tacho_debounce = 0,		
 		.divide = 8,
 	},
 	[4] = {
 		.limited_inverse = 0,
 		.threshold = 0,
-		.tacho_edge = F2F_EDGES,
-		.tacho_debounce = DEBOUNCE_3_CLK,
-		.pulse_pr = DEFAULT_FAN_PULSE_PR,		
+		.tacho_edge = 0,
+		.tacho_debounce = 0,		
 		.divide = 8,
 	},
 	[5] = {
 		.limited_inverse = 0,
 		.threshold = 0,
-		.tacho_edge = F2F_EDGES,
-		.tacho_debounce = DEBOUNCE_3_CLK,
-		.pulse_pr = DEFAULT_FAN_PULSE_PR,		
+		.tacho_edge = 0,
+		.tacho_debounce = 0,		
 		.divide = 8,
 	},
 	[6] = {
 		.limited_inverse = 0,
 		.threshold = 0,
-		.tacho_edge = F2F_EDGES,
-		.tacho_debounce = DEBOUNCE_3_CLK,
-		.pulse_pr = DEFAULT_FAN_PULSE_PR,		
+		.tacho_edge = 0,
+		.tacho_debounce = 0,		
 		.divide = 8,
 	},
 	[7] = {
 		.limited_inverse = 0,
 		.threshold = 0,
-		.tacho_edge = F2F_EDGES,
-		.tacho_debounce = DEBOUNCE_3_CLK,
-		.pulse_pr = DEFAULT_FAN_PULSE_PR,		
+		.tacho_edge = 0,
+		.tacho_debounce = 0,		
 		.divide = 8,
 	},
 	[8] = {
 		.limited_inverse = 0,
 		.threshold = 0,
-		.tacho_edge = F2F_EDGES,
-		.tacho_debounce = DEBOUNCE_3_CLK,
-		.pulse_pr = DEFAULT_FAN_PULSE_PR,		
+		.tacho_edge = 0,
+		.tacho_debounce = 0,		
 		.divide = 8,
 	},
 	[9] = {
 		.limited_inverse = 0,
 		.threshold = 0,
-		.tacho_edge = F2F_EDGES,
-		.tacho_debounce = DEBOUNCE_3_CLK,
-		.pulse_pr = DEFAULT_FAN_PULSE_PR,		
+		.tacho_edge = 0,
+		.tacho_debounce = 0,		
 		.divide = 8,
 	},
 	[10] = {
 		.limited_inverse = 0,
 		.threshold = 0,
-		.tacho_edge = F2F_EDGES,
-		.tacho_debounce = DEBOUNCE_3_CLK,
-		.pulse_pr = DEFAULT_FAN_PULSE_PR,		
+		.tacho_edge = 0,
+		.tacho_debounce = 0,		
 		.divide = 8,
 	},
 	[11] = {
 		.limited_inverse = 0,
 		.threshold = 0,
-		.tacho_edge = F2F_EDGES,
-		.tacho_debounce = DEBOUNCE_3_CLK,
-		.pulse_pr = DEFAULT_FAN_PULSE_PR,		
+		.tacho_edge = 0,
+		.tacho_debounce = 0,		
 		.divide = 8,
 	},
 	[12] = {
 		.limited_inverse = 0,
 		.threshold = 0,
-		.tacho_edge = F2F_EDGES,
-		.tacho_debounce = DEBOUNCE_3_CLK,
-		.pulse_pr = DEFAULT_FAN_PULSE_PR,		
+		.tacho_edge = 0,
+		.tacho_debounce = 0,		
 		.divide = 8,
 	},
 	[13] = {
 		.limited_inverse = 0,
 		.threshold = 0,
-		.tacho_edge = F2F_EDGES,
-		.tacho_debounce = DEBOUNCE_3_CLK,
-		.pulse_pr = DEFAULT_FAN_PULSE_PR,		
+		.tacho_edge = 0,
+		.tacho_debounce = 0,		
 		.divide = 8,
 	},
 	[14] = {
 		.limited_inverse = 0,
 		.threshold = 0,
-		.tacho_edge = F2F_EDGES,
-		.tacho_debounce = DEBOUNCE_3_CLK,
-		.pulse_pr = DEFAULT_FAN_PULSE_PR,		
+		.tacho_edge = 0,
+		.tacho_debounce = 0,		
 		.divide = 8,
 	},
 	[15] = {
 		.limited_inverse = 0,
 		.threshold = 0,
-		.tacho_edge = F2F_EDGES,
-		.tacho_debounce = DEBOUNCE_3_CLK,
-		.pulse_pr = DEFAULT_FAN_PULSE_PR,		
+		.tacho_edge = 0,
+		.tacho_debounce = 0,		
 		.divide = 8,
 	},
 };
@@ -427,10 +450,8 @@
 	bool pwm_present[16];
 	bool fan_tach_present[16];
 	struct aspeed_pwm_channel_params *pwm_channel;
-	struct aspeed_tacho_channel_params *tacho_channel;
-	/* for thermal */
+	struct aspeed_techo_channel_params *techo_channel;
 	struct aspeed_cooling_device *cdev[8];
-	/* for hwmon */
 	const struct attribute_group *groups[3];
 };
 
@@ -479,109 +500,103 @@
 }
 
 static void aspeed_set_fan_tach_ch_enable(struct aspeed_pwm_tachometer_data *priv, u8 fan_tach_ch,
-					  bool enable, u32 tacho_div)
+					  bool enable)
 {
+	u32 i = 0, j;
+	u32 divide_val = 0;
 	u32 reg_value = 0;
-
 	if(enable) {
-		/* divide = 2^(tacho_div*2) */
-		priv->tacho_channel[fan_tach_ch].divide = 1 << (tacho_div << 1);
-
-		reg_value = TACHO_ENABLE | 
-				(priv->tacho_channel[fan_tach_ch].tacho_edge << TECHIO_EDGE_BIT) |
-				(tacho_div << TACHO_CLK_DIV_BIT) |
-				(priv->tacho_channel[fan_tach_ch].tacho_debounce << TACHO_DEBOUNCE_BIT);
-
-		if(priv->tacho_channel[fan_tach_ch].limited_inverse)
-			reg_value |= TACHO_INVERS_LIMIT;
-
-		if(priv->tacho_channel[fan_tach_ch].threshold)
-			reg_value |= (TACHO_IER | priv->tacho_channel[fan_tach_ch].threshold); 
-
-		regmap_write(priv->regmap, ASPEED_TACHO_CTRL_CH(fan_tach_ch), reg_value);
+		//4 ^ n
+		//check pwm clk and to change techo devide 25KZ
+		for(i = 0; i < 12; i++) {
+			divide_val = 1;
+		 	for(j = 1; j <= i; j++)
+				divide_val *= 4;
+			if((priv->clk_freq/divide_val) < 250000)
+				break;
+		}
+		i--;
+		divide_val = ((1 << i) * (1 << i));
+		priv->techo_channel[fan_tach_ch].divide = i;
+
+		reg_value = TECHO_ENABLE | 
+				(priv->techo_channel[fan_tach_ch].tacho_edge << TECHIO_EDGE_BIT) |
+				(priv->techo_channel[fan_tach_ch].divide << TECHO_CLK_DIV_BIT) |
+				(priv->techo_channel[fan_tach_ch].tacho_debounce << TECHO_DEBOUNCE_BIT);
+
+		if(priv->techo_channel[fan_tach_ch].limited_inverse)
+			reg_value |= TECHO_INVERS_LIMIT;
+
+		if(priv->techo_channel[fan_tach_ch].threshold)
+			reg_value |= (TECHO_IER | priv->techo_channel[fan_tach_ch].threshold); 
+		regmap_write(priv->regmap, ASPEED_TECHO_CTRL_CH(fan_tach_ch), reg_value);
 	} else
-		regmap_update_bits(priv->regmap, ASPEED_TACHO_CTRL_CH(fan_tach_ch),  TACHO_ENABLE, 0);
+		regmap_update_bits(priv->regmap, ASPEED_TECHO_CTRL_CH(fan_tach_ch),  TECHO_ENABLE, 0);
 }
 
-/*
- * The PWM frequency = HCLK(200Mhz) / (clock division L bit *
- * clock division H bit * (period bit + 1))
- */
 static void aspeed_set_pwm_channel_fan_ctrl(struct aspeed_pwm_tachometer_data *priv,
 					 u8 index, u8 fan_ctrl)
 {
 	u32 duty_value,	ctrl_value;
-	u32 div_h, div_l, cal_freq;
-
 	if (fan_ctrl == 0) {
 		aspeed_set_pwm_channel_enable(priv->regmap, index, false);
 	} else {
-		cal_freq = priv->clk_freq / (DEFAULT_PWM_PERIOD + 1);
-		//calculate for target frequence 
-		for(div_l = 0; div_l < 0x100; div_l++) {
-			for(div_h = 0; div_h < 0x10; div_h++) {
-//				printk("div h %x, l : %x , freq %ld \n", div_h, div_l, (cal_freq / (BIT(div_h) * (div_l + 1))));
-				if((cal_freq / (BIT(div_h) * (div_l + 1))) < priv->pwm_channel[index].target_freq)
-					break;
-			}
-			if((cal_freq / (BIT(div_h) * (div_l + 1))) < priv->pwm_channel[index].target_freq)
-				break;
-		}
-
-		priv->pwm_channel[index].pwm_freq = cal_freq / (BIT(div_h) * (div_l + 1));
-//		printk("div h %x, l : %x pwm out clk %d \n", div_h, div_l, priv->pwm_channel[index].pwm_freq);
-//		printk("hclk %ld, target pwm freq %d, real pwm freq %d\n", priv->clk_freq, priv->pwm_channel[index].target_freq, priv->pwm_channel[index].pwm_freq);
-
-		ctrl_value = (div_h << 8) | div_l;
-
-		duty_value = (DEFAULT_PWM_PERIOD << PWM_PERIOD_BIT) | 
-					(0 << PWM_RISING_POINT_BIT) | (fan_ctrl << PWM_FALLING_POINT_BIT);
+		duty_value = (priv->pwm_channel[index].period << PWM_PERIOD_BIT) | 
+					(0 << PWM_RISING_RISING_BIT) | (fan_ctrl << PWM_RISING_FALLING_BIT);
+		ctrl_value = (priv->pwm_channel[index].divide_h << 8) | priv->pwm_channel[index].divide_l;
 
 		if (priv->pwm_channel[index].load_wdt_enable) {
 			ctrl_value |= PWM_DUTY_LOAD_AS_WDT_EN;
-			ctrl_value |= priv->pwm_channel[index].load_wdt_selection << PWM_LOAD_SEL_AS_WDT_BIT;
-			duty_value |= (priv->pwm_channel[index].load_wdt_rising_falling_pt << PWM_RISING_FALLING_AS_WDT_BIT);
+			if(priv->pwm_channel[index].load_wdt_selection) {
+				ctrl_value |= PWM_LOAD_AS_WDT;
+				duty_value |= (priv->pwm_channel[index].load_wdt_rising_falling_pt << PWM_RISING_FALLING_AS_WDT_BIT);
+			} else {
+				duty_value |= (priv->pwm_channel[index].load_wdt_rising_falling_pt << PWM_RISING_FALLING_AS_WDT_BIT);
+			}
 		}
 
 		regmap_write(priv->regmap, ASPEED_PWM_DUTY_CYCLE_CH(index), duty_value);
-		regmap_write(priv->regmap, ASPEED_PWM_CTRL_CH(index), ctrl_value);
 
+		regmap_write(priv->regmap, ASPEED_PWM_CTRL_CH(index), ctrl_value);
 		aspeed_set_pwm_channel_enable(priv->regmap, index, true);
 	}
 }
 
+#define BOTH_EDGES 0x02 /* 10b */
+
 static int aspeed_get_fan_tach_ch_rpm(struct aspeed_pwm_tachometer_data *priv,
 				      u8 fan_tach_ch)
 {
-	u32 raw_data, tach_div, clk_source, val;
+	u32 raw_data, tach_div, clk_source, val = 0;
+	u8 mode, both;
 	int i, retries = 3;
-
 	for(i = 0; i < retries; i++) {
-		regmap_read(priv->regmap, ASPEED_TACHO_STS_CH(fan_tach_ch), &val);
+		regmap_read(priv->regmap, ASPEED_TECHO_STS_CH(fan_tach_ch), &val);
 		if (TACHO_FULL_MEASUREMENT & val)
 			break;
 	}
 
 	raw_data = val & TACHO_VALUE_MASK;
+
 	if(raw_data == 0xfffff)
 		return 0;
 
-	raw_data += 1;
-
+	tach_div = priv->techo_channel[fan_tach_ch].divide;
 	/*
 	 * We need the mode to determine if the raw_data is double (from
 	 * counting both edges).
 	 */
-	tach_div = raw_data * (priv->tacho_channel[fan_tach_ch].divide) * (priv->tacho_channel[fan_tach_ch].pulse_pr);
-
-//	printk("clk %ld, raw_data %d , tach_div %d  \n", priv->clk_freq, raw_data, tach_div);
-	
+	mode = priv->techo_channel[fan_tach_ch].tacho_edge;
+	both = (mode & BOTH_EDGES) ? 1 : 0;
+	//tach_div = (tach_div * 2) * (0x1 << both);
+	tach_div = 1 << (tach_div << 1);
 	clk_source = priv->clk_freq;
 
 	if (raw_data == 0)
 		return 0;
 
-	return ((clk_source / tach_div) * 60);
+	clk_source = clk_source / (2 * (raw_data + 1) * tach_div);
+	return (clk_source * 60);
 
 }
 
@@ -593,31 +608,18 @@
 	int ret;
 	struct aspeed_pwm_tachometer_data *priv = dev_get_drvdata(dev);
 	long fan_ctrl;
-	u8 org_falling = priv->pwm_channel[index].falling;
-
 	ret = kstrtol(buf, 10, &fan_ctrl);
 	if (ret != 0)
 		return ret;
 
-	if (fan_ctrl < 0 || fan_ctrl > DEFAULT_PWM_PERIOD)
+	if (fan_ctrl < 0 || fan_ctrl > priv->pwm_channel[index].period)
 		return -EINVAL;
 
 	if (priv->pwm_channel[index].falling == fan_ctrl)
 		return count;
 
 	priv->pwm_channel[index].falling = fan_ctrl;
-
-	if(fan_ctrl == 0)
-		aspeed_set_pwm_channel_enable(priv->regmap, index, false);
-	else {
-		if(fan_ctrl == DEFAULT_PWM_PERIOD)
-			regmap_update_bits(priv->regmap, ASPEED_PWM_DUTY_CYCLE_CH(index), GENMASK(15, 0), 0);
-		else
-			regmap_update_bits(priv->regmap, ASPEED_PWM_DUTY_CYCLE_CH(index), GENMASK(15, 8), (fan_ctrl << PWM_FALLING_POINT_BIT));
-	}
-
-	if(org_falling == 0)
-		aspeed_set_pwm_channel_enable(priv->regmap, index, true);
+	aspeed_set_pwm_channel_fan_ctrl(priv, index, fan_ctrl);
 
 	return count;
 }
@@ -628,7 +630,6 @@
 	struct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);
 	int index = sensor_attr->index;
 	struct aspeed_pwm_tachometer_data *priv = dev_get_drvdata(dev);
-
 	return sprintf(buf, "%u\n", priv->pwm_channel[index].falling);
 }
 
@@ -639,7 +640,6 @@
 	int index = sensor_attr->index;
 	int rpm;
 	struct aspeed_pwm_tachometer_data *priv = dev_get_drvdata(dev);
-
 	rpm = aspeed_get_fan_tach_ch_rpm(priv, index);
 	if (rpm < 0)
 		return rpm;
@@ -652,7 +652,6 @@
 {
 	struct device *dev = container_of(kobj, struct device, kobj);
 	struct aspeed_pwm_tachometer_data *priv = dev_get_drvdata(dev);
-
 	if (!priv->pwm_present[index])
 		return 0;
 	return a->mode;
@@ -663,7 +662,6 @@
 {
 	struct device *dev = container_of(kobj, struct device, kobj);
 	struct aspeed_pwm_tachometer_data *priv = dev_get_drvdata(dev);
-
 	if (!priv->fan_tach_present[index])
 		return 0;
 	return a->mode;
@@ -793,15 +791,14 @@
 }
 
 static void aspeed_create_fan_tach_channel(struct aspeed_pwm_tachometer_data *priv,
-					   u8 *fan_tach_ch, int count, u32 fan_pulse_pr, u32 tacho_div)
+					   u8 *fan_tach_ch,
+					   int count)
 {
 	u8 val, index;
-
 	for (val = 0; val < count; val++) {
 		index = fan_tach_ch[val];
 		priv->fan_tach_present[index] = true;
-		priv->tacho_channel[index].pulse_pr = fan_pulse_pr;
-		aspeed_set_fan_tach_ch_enable(priv, index, true, tacho_div);
+		aspeed_set_fan_tach_ch_enable(priv, index, true);
 	}
 }
 
@@ -810,7 +807,6 @@
 			    unsigned long *state)
 {
 	struct aspeed_cooling_device *cdev = tcdev->devdata;
-
 	*state = cdev->max_state;
 
 	return 0;
@@ -821,7 +817,6 @@
 			    unsigned long *state)
 {
 	struct aspeed_cooling_device *cdev = tcdev->devdata;
-
 	*state = cdev->cur_state;
 
 	return 0;
@@ -835,7 +830,6 @@
 
 	if (state > cdev->max_state)
 		return -EINVAL;
-
 	cdev->cur_state = state;
 	cdev->priv->pwm_channel[cdev->pwm_channel].falling =
 					cdev->cooling_levels[cdev->cur_state];
@@ -858,7 +852,6 @@
 {
 	int ret;
 	struct aspeed_cooling_device *cdev;
-
 	cdev = devm_kzalloc(dev, sizeof(*cdev), GFP_KERNEL);
 	if (!cdev)
 		return -ENOMEM;
@@ -897,30 +890,21 @@
 			     struct aspeed_pwm_tachometer_data *priv)
 {
 	u8 *fan_tach_ch;
-	u32 fan_pulse_pr;
-	u32 tacho_div;
 	u32 pwm_channel;
-	u32 target_pwm_freq = 0;
 	int ret, count;
 
 	ret = of_property_read_u32(child, "reg", &pwm_channel);
 	if (ret)
 		return ret;
 
-	ret = of_property_read_u32(child, "aspeed,target_pwm", &target_pwm_freq);
-	if (ret)
-		target_pwm_freq = DEFAULT_TARGET_PWM_FREQ;
-
 	aspeed_create_pwm_channel(priv, (u8)pwm_channel);
 
 	ret = of_property_count_u8_elems(child, "cooling-levels");
 	if (ret > 0) {
-		if (IS_ENABLED(CONFIG_THERMAL)) {
-			ret = aspeed_create_pwm_cooling(dev, child, priv, pwm_channel,
-							ret);
-			if (ret)
-				return ret;
-		}
+		ret = aspeed_create_pwm_cooling(dev, child, priv, pwm_channel,
+						ret);
+		if (ret)
+			return ret;
 	}
 
 	count = of_property_count_u8_elems(child, "aspeed,fan-tach-ch");
@@ -935,16 +919,7 @@
 					fan_tach_ch, count);
 	if (ret)
 		return ret;
-	
-	ret = of_property_read_u32(child, "aspeed,pulse-pr", &fan_pulse_pr);
-	if (ret)
-		fan_pulse_pr = DEFAULT_FAN_PULSE_PR;
-
-	ret = of_property_read_u32(child, "aspeed,tacho-div", &tacho_div);
-	if (ret)
-		tacho_div = DEFAULT_TACHO_DIV;
-	
-	aspeed_create_fan_tach_channel(priv, fan_tach_ch, count, fan_pulse_pr, tacho_div);
+	aspeed_create_fan_tach_channel(priv, fan_tach_ch, count);
 
 	return 0;
 }
@@ -972,7 +947,7 @@
 		return -ENOMEM;
 
 	priv->pwm_channel = default_pwm_params;	
-	priv->tacho_channel = default_tacho_params;
+	priv->techo_channel = default_techo_params;
 	priv->regmap = devm_regmap_init(dev, NULL, (__force void *)regs,
 			&aspeed_pwm_tachometer_regmap_config);
 	if (IS_ERR(priv->regmap))
@@ -1004,7 +979,6 @@
 	priv->groups[0] = &pwm_dev_group;
 	priv->groups[1] = &fan_dev_group;
 	priv->groups[2] = NULL;
-	dev_info(dev, "pwm tach probe done\n");
 	hwmon = devm_hwmon_device_register_with_groups(dev,
 						       "aspeed_pwm_tachometer",
 						       priv, priv->groups);
