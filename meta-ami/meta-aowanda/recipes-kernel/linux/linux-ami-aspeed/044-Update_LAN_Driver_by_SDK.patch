diff -Naur linux_org/drivers/net/ethernet/faraday/ftgmac100.c linux/drivers/net/ethernet/faraday/ftgmac100.c
--- linux_org/drivers/net/ethernet/faraday/ftgmac100.c	2021-01-07 10:21:11.899364508 +0800
+++ linux/drivers/net/ethernet/faraday/ftgmac100.c	2021-01-07 11:12:50.674154156 +0800
@@ -47,6 +47,9 @@
 
 /* Min number of tx ring entries before stopping queue */
 #define TX_THRESHOLD		(MAX_SKB_FRAGS + 1)
+#if (DEF_TX_QUEUE_ENTRIES < 2 * TX_THRESHOLD)
+#error "TX queue entries not enough"
+#endif
 
 #define FTGMAC_100MHZ		100000000
 #define FTGMAC_25MHZ		25000000
@@ -97,6 +100,7 @@
 	int cur_speed;
 	int cur_duplex;
 	bool use_ncsi;
+	bool use_fixed_phy;
 
 	/* Multicast filter settings */
 	u32 maht0;
@@ -108,7 +112,7 @@
 	bool aneg_pause;
 
 	/* Misc */
-	bool need_mac_restart;
+	volatile bool need_mac_restart;
 	bool is_aspeed;
 	u32 tm_reg_mask;
 };
@@ -653,6 +657,9 @@
 	if (ctl_stat & FTGMAC100_TXDES0_TXDMA_OWN)
 		return false;
 
+	if ((ctl_stat & ~(priv->txdes0_edotr_mask)) == 0)
+		return false;
+
 	skb = priv->tx_skbs[pointer];
 	netdev->stats.tx_packets++;
 	netdev->stats.tx_bytes += skb->len;
@@ -761,6 +768,9 @@
 	/* Grab the next free tx descriptor */
 	pointer = priv->tx_pointer;
 	txdes = first = &priv->txdes[pointer];
+	if ((le32_to_cpu(txdes->txdes0) & ~priv->txdes0_edotr_mask) != 0) {
+		goto drop;
+	}
 
 	/* Setup it up with the packet head. Don't write the head to the
 	 * ring just yet
@@ -793,6 +803,11 @@
 		/* Setup descriptor */
 		priv->tx_skbs[pointer] = skb;
 		txdes = &priv->txdes[pointer];
+
+		if ((le32_to_cpu(txdes->txdes0) & ~priv->txdes0_edotr_mask) != 0) {
+			goto dma_err;
+		}
+
 		ctl_stat = ftgmac100_base_tx_ctlstat(priv, pointer);
 		ctl_stat |= FTGMAC100_TXDES0_TXDMA_OWN;
 		ctl_stat |= FTGMAC100_TXDES0_TXBUF_SIZE(len);
@@ -827,6 +842,18 @@
 			netif_wake_queue(netdev);
 	}
 
+	/* When sending UDP packets, we may never receive a packet to activate 
+	 * the NAPI scheduler. And hence we don't have chance to free the TX 
+	 * data.  The workaround is to enable FTGMAC100_INT_XPKT_ETH, then the 
+	 * NAPI scheduler can be woke up in the ISR.
+	*/
+	if ((skb->protocol == cpu_to_be16(ETH_P_IP)) &&
+	    (IPPROTO_UDP == ip_hdr(skb)->protocol)) {
+		iowrite32(FTGMAC100_INT_XPKT_ETH |
+				  ioread32(priv->base + FTGMAC100_OFFSET_IER),
+			  priv->base + FTGMAC100_OFFSET_IER);
+	}
+
 	/* Poke transmitter to read the updated TX descriptors */
 	iowrite32(1, priv->base + FTGMAC100_OFFSET_NPTXPD);
 
@@ -1045,6 +1072,7 @@
 
 	/* Disable all interrupts */
 	iowrite32(0, priv->base + FTGMAC100_OFFSET_IER);
+	ioread32(priv->base + FTGMAC100_OFFSET_IER);
 
 	/* Reset the adapter asynchronously */
 	schedule_work(&priv->reset_task);
@@ -1223,6 +1251,219 @@
 	return 0;
 }
 
+static int ftgmac100_run_loopback(struct net_device *netdev, uint32_t loopback_mode)
+{
+	struct ftgmac100 *priv = netdev_priv(netdev);
+	struct ftgmac100_rxdes *rxdes;	
+	struct sk_buff *txskb, *rxskb;
+	dma_addr_t map;
+	unsigned int pkt_size = 60, pointer, rx_size;
+	uint32_t reg, status;
+	int i, err;
+	unsigned char *txpkt, *rxpkt;
+	bool rx_pkt_found = false;
+
+	if (netif_running(netdev)) {
+		netif_trans_update(netdev);
+		napi_disable(&priv->napi);
+		netif_stop_queue(netdev);
+	}
+
+	/* Stop and reset the MAC */
+	ftgmac100_stop_hw(priv);
+	err = ftgmac100_reset_and_config_mac(priv);
+	if (err) {
+		/* Not much we can do ... it might come back... */
+		netdev_err(netdev, "attempting to continue...\n");
+	}
+
+	/* Free all rx and tx buffers */
+	ftgmac100_free_buffers(priv);
+
+	/* Re-init descriptors (adjust queue sizes) */
+	ftgmac100_init_rings(priv);
+
+	/* Realloc rx descriptors */
+	err = ftgmac100_alloc_rx_buffers(priv);
+
+	/* Reinit and restart HW */
+	ftgmac100_init_hw(priv);
+	ftgmac100_config_pause(priv);
+	ftgmac100_start_hw(priv);
+
+	/* Disable all interrupts */
+	iowrite32(0, priv->base + FTGMAC100_OFFSET_IER);
+
+	if (FTGMAC100_MAC_LOOPBACK == loopback_mode) {
+		reg = ioread32(priv->base + FTGMAC100_OFFSET_REVR) |
+		      FTGMAC100_INTERNAL_LOOPBACK_EN;
+		iowrite32(reg, priv->base + FTGMAC100_OFFSET_REVR);
+	}
+
+	/**
+	 * prepare TX packet
+	 *   MAC DA: priv->netdev->dev_addr
+	 *   MAC SA: priv->netdev->dev_addr
+	 *   ETH type: ETH_P_LOOP (0060)
+	 *   payload: 0x00, 0x01, 0x02, ... , 0x2b, 0x2c, 0x2d
+	 *   FSC: generated by HW (MAC engine)
+	*/
+	txskb = netdev_alloc_skb_ip_align(netdev, MAX_PKT_SIZE);
+	if (unlikely(!txskb)) {
+		netdev_warn(netdev, "failed to allocate tx skb\n");
+		err = -ENOMEM;
+		goto fail;
+	} 		
+
+	txpkt = skb_put(txskb, pkt_size);
+	memcpy(txpkt, priv->netdev->dev_addr, ETH_ALEN);
+	txpkt += ETH_ALEN;
+	memcpy(txpkt, priv->netdev->dev_addr, ETH_ALEN);
+	txpkt += ETH_ALEN;
+
+	*txpkt++ = ETH_P_LOOP >> 8;
+	*txpkt++ = ETH_P_LOOP & 0xff;
+	
+	for (i = 0; i < pkt_size - ETH_HLEN; i++)
+		*txpkt++ = (unsigned char) (i & 0xff);	
+
+	ftgmac100_hard_start_xmit(txskb, netdev);
+	udelay(10);
+
+	/**
+	 * receive ingress packet
+	*/
+	pointer = priv->rx_pointer;
+	rxdes = &priv->rxdes[pointer];
+
+	for (i = 0; i < 10; i++) {
+		status = le32_to_cpu(rxdes->rxdes0);
+		if (status & FTGMAC100_RXDES0_RXPKT_RDY) {
+			rx_pkt_found = true;
+			break;	
+		} 
+		udelay(1);
+	}
+
+	dma_rmb();
+
+	if (!rx_pkt_found) {
+		err = -EPERM;
+		goto fail;
+	}
+
+	if (unlikely(status & RXDES0_ANY_ERROR)) {
+		err = -EIO;
+		goto fail;
+	}
+
+	rx_size = status & FTGMAC100_RXDES0_VDBC;
+	rxskb = priv->rx_skbs[pointer];
+	skb_put(rxskb, rx_size);
+	map = le32_to_cpu(rxdes->rxdes3);
+	dma_unmap_single(priv->dev, map, rx_size, DMA_FROM_DEVICE);
+	ftgmac100_alloc_rx_buf(priv, pointer, rxdes, GFP_ATOMIC);
+	priv->rx_pointer = ftgmac100_next_rx_pointer(priv, pointer);
+
+	/**
+	 * compare the ingress packet with the egress packet.  FCS shall be 
+	 * excluded since the FCS of the egress packet is provided by HW.
+	*/
+	if ((rx_size - ETH_FCS_LEN) != pkt_size) {
+		err = -EIO;
+		goto fail;
+	}
+
+	if (0) {
+		txpkt = txskb->data;
+		rxpkt = rxskb->data;
+		for (i = 0; i < rx_size; i++)
+			printk("%02x %02x\n", *txpkt++, *rxpkt++);
+	}
+
+	if (0 != memcmp(txskb->data, rxskb->data, pkt_size)) {
+		err = -EIO;
+		goto fail;
+	}
+
+	err = 0;
+
+fail:
+	if (netif_running(netdev)) {
+		netif_trans_update(netdev);
+		napi_enable(&priv->napi);
+		netif_start_queue(netdev);
+	}
+
+	iowrite32(FTGMAC100_INT_ALL, priv->base + FTGMAC100_OFFSET_IER);
+
+	reg = ioread32(priv->base + FTGMAC100_OFFSET_REVR) &
+	      (~FTGMAC100_INTERNAL_LOOPBACK_EN);
+	iowrite32(reg, priv->base + FTGMAC100_OFFSET_REVR);
+
+	return err;
+}
+/* return strings of the test items */
+static const
+char ftgmac100_tests_str_tbl[FTGMAC100_NUM_TESTS][ETH_GSTRING_LEN] = {
+	"internal loopback (offline)     ",
+	"external loopback (offline)     ",
+};
+
+static void ftgmac100_get_strings(struct net_device *dev, u32 stringset, u8 *buf)
+{
+	if (ETH_SS_TEST == stringset) {
+		memcpy(buf, ftgmac100_tests_str_tbl,
+		       FTGMAC100_NUM_TESTS * ETH_GSTRING_LEN);
+	}
+}
+
+/* return number of test items */
+static int ftgmac100_get_sset_count(struct net_device *netdev, int stringset)
+{
+	if (ETH_SS_TEST == stringset)
+		return FTGMAC100_NUM_TESTS;
+	else
+		return -EINVAL;
+}
+
+void ftgmac100_self_test(struct net_device *netdev,
+			 struct ethtool_test *etest, u64 *result) 
+{
+	struct ftgmac100 *priv = netdev_priv(netdev);
+	struct platform_device *pdev = to_platform_device(priv->dev);
+	struct device_node *np = pdev->dev.of_node;
+
+	if (!(np && of_device_is_compatible(np, "aspeed,ast2600-mac"))) {
+		netdev_warn(netdev, "self-test not support\n");
+		etest->flags |= ETH_TEST_FL_FAILED;
+		return;
+	}
+
+	if (0 == (etest->flags & ETH_TEST_FL_OFFLINE)) {
+		netdev_warn(netdev, "no online test items\n");
+		etest->flags |= ETH_TEST_FL_FAILED;
+		return;
+	}
+
+	/* internal loopback */
+	result[0] = ftgmac100_run_loopback(netdev, FTGMAC100_MAC_LOOPBACK);
+	if (result[0])
+		etest->flags |= ETH_TEST_FL_FAILED;
+
+	/* external loopback */
+	if (etest->flags & ETH_TEST_FL_EXTERNAL_LB) {
+		result[1] = ftgmac100_run_loopback(netdev, FTGMAC100_EXT_LOOPBACK);
+		etest->flags |= ETH_TEST_FL_EXTERNAL_LB_DONE;
+		if (result[1])
+			etest->flags |= ETH_TEST_FL_FAILED;
+	}	
+
+	if (netif_running(netdev))
+		schedule_work(&priv->reset_task);
+}
+
+
 static const struct ethtool_ops ftgmac100_ethtool_ops = {
 	.get_drvinfo		= ftgmac100_get_drvinfo,
 	.get_link		= ethtool_op_get_link,
@@ -1233,6 +1474,9 @@
 	.set_ringparam		= ftgmac100_set_ringparam,
 	.get_pauseparam		= ftgmac100_get_pauseparam,
 	.set_pauseparam		= ftgmac100_set_pauseparam,
+	.self_test 		= ftgmac100_self_test,
+	.get_strings		= ftgmac100_get_strings,
+	.get_sset_count		= ftgmac100_get_sset_count,
 };
 
 static irqreturn_t ftgmac100_interrupt(int irq, void *dev_id)
@@ -1244,6 +1488,7 @@
 	/* Fetch and clear interrupt bits, process abnormal ones */
 	status = ioread32(priv->base + FTGMAC100_OFFSET_ISR);
 	iowrite32(status, priv->base + FTGMAC100_OFFSET_ISR);
+	ioread32(priv->base + FTGMAC100_OFFSET_ISR);
 	if (unlikely(status & FTGMAC100_INT_BAD)) {
 
 		/* RX buffer unavailable */
@@ -1264,6 +1509,7 @@
 				netdev_warn(netdev,
 					   "AHB bus error ! Resetting chip.\n");
 			iowrite32(0, priv->base + FTGMAC100_OFFSET_IER);
+			ioread32(priv->base + FTGMAC100_OFFSET_IER);
 			schedule_work(&priv->reset_task);
 			return IRQ_HANDLED;
 		}
@@ -1279,7 +1525,7 @@
 
 	/* Only enable "bad" interrupts while NAPI is on */
 	iowrite32(new_mask, priv->base + FTGMAC100_OFFSET_IER);
-
+	ioread32(priv->base + FTGMAC100_OFFSET_IER);
 	/* Schedule NAPI bh */
 	napi_schedule_irqoff(&priv->napi);
 
@@ -1314,11 +1560,18 @@
 	 * after an RX overflow
 	 */
 	if (unlikely(priv->need_mac_restart)) {
+		/* clear status again */
+		iowrite32(ioread32(priv->base + FTGMAC100_OFFSET_ISR) &
+			      FTGMAC100_INT_BAD,
+			  priv->base + FTGMAC100_OFFSET_ISR);
+		ioread32(priv->base + FTGMAC100_OFFSET_ISR);
 		ftgmac100_start_hw(priv);
+		priv->need_mac_restart = false;
 
 		/* Re-enable "bad" interrupts */
 		iowrite32(FTGMAC100_INT_BAD,
 			  priv->base + FTGMAC100_OFFSET_IER);
+		ioread32(priv->base + FTGMAC100_OFFSET_IER);
 	}
 
 	/* As long as we are waiting for transmit packets to be
@@ -1352,6 +1605,7 @@
 		/* enable all interrupts */
 		iowrite32(FTGMAC100_INT_ALL,
 			  priv->base + FTGMAC100_OFFSET_IER);
+		ioread32(priv->base + FTGMAC100_OFFSET_IER);			  
 	}
 
 	return work_done;
@@ -1380,7 +1634,7 @@
 
 	/* Enable all interrupts */
 	iowrite32(FTGMAC100_INT_ALL, priv->base + FTGMAC100_OFFSET_IER);
-
+	ioread32(priv->base + FTGMAC100_OFFSET_IER);
 	return err;
 }
 
@@ -1454,6 +1708,9 @@
 	if (priv->use_ncsi) {
 		priv->cur_duplex = DUPLEX_FULL;
 		priv->cur_speed = SPEED_100;
+	} else if (priv->use_fixed_phy) {
+	    	priv->cur_duplex = netdev->phydev->duplex;
+		priv->cur_speed = netdev->phydev->speed;
 	} else {
 		priv->cur_duplex = 0;
 		priv->cur_speed = 0;
@@ -1524,6 +1781,7 @@
 
 	/* disable all interrupts */
 	iowrite32(0, priv->base + FTGMAC100_OFFSET_IER);
+	ioread32(priv->base + FTGMAC100_OFFSET_IER);
 
 	netif_stop_queue(netdev);
 	napi_disable(&priv->napi);
@@ -1556,6 +1814,7 @@
 
 	/* Disable all interrupts */
 	iowrite32(0, priv->base + FTGMAC100_OFFSET_IER);
+	ioread32(priv->base + FTGMAC100_OFFSET_IER);
 
 	/* Do the reset outside of interrupt context */
 	schedule_work(&priv->reset_task);
@@ -1712,8 +1971,10 @@
 		return;
 
 	phy_disconnect(netdev->phydev);
-	mdiobus_unregister(priv->mii_bus);
-	mdiobus_free(priv->mii_bus);
+	if (priv->mii_bus) {
+		mdiobus_unregister(priv->mii_bus);
+		mdiobus_free(priv->mii_bus);
+	}
 }
 
 static void ftgmac100_ncsi_handler(struct ncsi_dev *nd)
@@ -1825,8 +2086,11 @@
 		priv->rxdes0_edorr_mask = BIT(30);
 		priv->txdes0_edotr_mask = BIT(30);
 		priv->is_aspeed = true;
-		if (of_device_is_compatible(np, "aspeed,ast2600-mac"))
-			priv->tm_reg_mask = FTGMAC100_TM_RQ_TX_VALID_DIS | FTGMAC100_TM_RQ_RR_IDLE_PREV;
+		/* Disable ast2600 problematic HW arbitration */
+		if (of_device_is_compatible(np, "aspeed,ast2600-mac")) {
+			iowrite32(FTGMAC100_TM_DEFAULT,
+				  priv->base + FTGMAC100_OFFSET_TM);
+		}
 	} else {
 		priv->rxdes0_edorr_mask = BIT(15);
 		priv->txdes0_edotr_mask = BIT(15);
@@ -1846,18 +2110,22 @@
 			goto err_ncsi_dev;
 	} else if (np && of_get_property(np, "phy-handle", NULL)) {
 		struct phy_device *phy;
+		priv->use_fixed_phy = of_phy_is_fixed_link(pdev->dev.of_node);
 
 		phy = of_phy_get_and_connect(priv->netdev, np,
 					     &ftgmac100_adjust_link);
 		if (!phy) {
 			dev_err(&pdev->dev, "Failed to connect to phy\n");
+			if (priv->use_fixed_phy)
+				of_phy_deregister_fixed_link(pdev->dev.of_node);
 			goto err_setup_mdio;
 		}
 
 		/* Indicate that we support PAUSE frames (see comment in
 		 * Documentation/networking/phy.txt)
 		 */
-		phy_support_asym_pause(phy);
+		if (!priv->use_fixed_phy)
+			phy_support_asym_pause(phy);
 
 		/* Display what we found */
 		phy_attached_info(phy);
@@ -1949,7 +2217,9 @@
 	iounmap(priv->base);
 	release_resource(priv->res);
 
-	netif_napi_del(&priv->napi);
+	if (priv->use_fixed_phy)
+		of_phy_deregister_fixed_link(pdev->dev.of_node);
+
 	free_netdev(netdev);
 	return 0;
 }
diff -Naur linux_org/drivers/net/ethernet/faraday/ftgmac100.h linux/drivers/net/ethernet/faraday/ftgmac100.h
--- linux_org/drivers/net/ethernet/faraday/ftgmac100.h	2021-01-07 10:21:13.823276633 +0800
+++ linux/drivers/net/ethernet/faraday/ftgmac100.h	2021-01-07 11:12:48.666245613 +0800
@@ -138,6 +138,7 @@
  * Feature Register
  */
 #define FTGMAC100_REVR_NEW_MDIO_INTERFACE	BIT(31)
+#define FTGMAC100_INTERNAL_LOOPBACK_EN		BIT(30)
 
 /*
  * Receive buffer size register
@@ -271,4 +272,10 @@
 #define FTGMAC100_RXDES1_UDP_CHKSUM_ERR	(1 << 26)
 #define FTGMAC100_RXDES1_IP_CHKSUM_ERR	(1 << 27)
 
+
+/* self test */
+#define FTGMAC100_NUM_TESTS		2
+
+#define FTGMAC100_MAC_LOOPBACK		0
+#define FTGMAC100_EXT_LOOPBACK		1
 #endif /* __FTGMAC100_H */
