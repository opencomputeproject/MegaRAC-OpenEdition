--- a/board/aspeed/evb_ast2600/ast-irq.c	1970-01-01 08:00:00.000000000 +0800
+++ b/board/aspeed/evb_ast2600/ast-irq.c	2020-06-18 17:34:37.392096882 +0800
@@ -0,0 +1,401 @@
+/*
+ * Copyright 2018 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <common.h>
+#include <netdev.h>
+#include <asm/io.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define GIC_DISTRIBUTOR_OFFSET 0x1000
+#define GIC_CPU_OFFSET 0x2000
+#define GIC_INTERFACE_OFFSET 0x4000
+#define GIC_VIRT_OFFSET 0x6000
+
+/* GIC_DISTRIBUTOR_OFFSET register offsets */
+#define GICD_CTLR 0x000
+#define GICD_TYPER 0x004
+#define GICD_IIDR 0x008
+#define GICD_IGROUPRn 0x080
+#define GICD_ISENABLERn 0x100
+#define GICD_ICENABLERn 0x180
+#define GICD_ISPENDRn 0x200
+#define GICD_ICPENDRn 0x280
+#define GICD_ISACTIVERn 0x300
+#define GICD_ICACTIVERn 0x380
+#define GICD_IPRIORITYRn 0x400
+#define GICD_ITARGETSRn 0x800
+#define GICD_ICFGRn 0xc00
+#define GICD_PPISR 0xd00
+#define GICD_SPISRn 0xd04
+#define GICD_SGIR 0xf00
+#define GICD_CPENDINGIRn 0xf10
+#define GICD_SPENDINGIRn 0xf10
+#define GICD_PIDR4 0xfd0
+#define GICD_PIDR5 0xfd4
+#define GICD_PIDR6 0xfd8
+#define GICD_PIDR7 0xfdc
+#define GICD_PIDR0 0xfe0
+#define GICD_PIDR1 0xfe4
+#define GICD_PIDR2 0xfe8
+#define GICD_PIDR3 0xfec
+#define GICD_CIDR0 0xff0
+#define GICD_CIDR1 0xff4
+#define GICD_CIDR2 0xff8
+#define GICD_CIDR3 0xffc
+
+#define GIC_DISTRIBUTOR_IMPLEMENTER_MAGIC 0x0100143b
+
+/* GIC_CPU_OFFSET register offsets */
+#define GICC_CTLR 0x0000
+#define GICC_PMRn 0x0004
+#define GICC_BPR 0x0008
+#define GICC_IAR 0x000c
+#define GICC_EOIR 0x0010
+#define GICC_RPR 0x0014
+#define GICC_HPPIR 0x0018
+#define GICC_ABPR 0x001c
+#define GICC_AIAR 0x0020
+#define GICC_AEOIR 0x0024
+#define GICC_AHPPIR 0x0028
+#define GICC_APR0 0x00d0
+#define GICC_NSAPR0 0x00e0
+#define GICC_IIDR 0x00fc
+#define GICC_DIR  0x1000
+
+#define GIC_CPU_IMPLEMENTER_MAGIC      0x0102143b
+#define GICC_IAR_INT_ID_MASK           0x3ff
+#define GIC_CPU_DEACTIVATE             0x1000
+
+/* GIC_INTERFACE_OFFSET register offsets */
+#define GICH_HCR 0x000
+#define GICH_VTR 0x004
+#define GICH_VMCR 0x008
+#define GICH_MISR 0x010
+#define GICH_EISR0 0x020
+#define GICH_ELSR0 0x020
+#define GICH_APR0 0x0f0
+#define GICH_LR0 0x100
+#define GICH_LR1 0x104
+#define GICH_LR2 0x108
+#define GICH_LR3 0x10c
+
+/* GIC_VIRT_OFFSET register offsets */
+#define GICV_CTLR 0x0000
+#define GICV_PMR 0x0004
+#define GICV_BPR 0x0008
+#define GICV_IAR 0x000c
+#define GICV_EOIR 0x0010
+#define GICV_RPR 0x0014
+#define GICV_HPPIR 0x0018
+#define GICV_ABPR 0x001c
+#define GICV_AIAR 0x0020
+#define GICV_AEOIR 0x0024
+#define GICV_AHPPIR 0x0028
+#define GICV_APR0 0x00d0
+#define GICV_NSAPR0 0x00e0
+#define GICV_IIDR 0x00fc
+#define GICV_DIR  0x1000
+
+#define GIC_VIRT_CPU_IMPLEMENTER_MAGIC 0x0102143b
+
+#define GICD_CTLR_ENABLE 0x03 /*enable group 0 and 1*/
+#define GICC_CTLR_ENABLE 0x03
+#define GICD_ITARGET_ALL 0xffffffff
+#define GICD_INT_DEF_PRI 0xa0
+#define GICD_INT_DEF_PRI_X4 (\
+               (GICD_INT_DEF_PRI << 24) |\
+               (GICD_INT_DEF_PRI << 16) |\
+               (GICD_INT_DEF_PRI << 8) |\
+               GICD_INT_DEF_PRI)
+
+#define GICD_INT_ACTLOW_LVLTRIG 0
+#define GICD_INT_EN_CLR_X32 0xffffffff
+#define GICD_INT_EN_CLR_PPI 0xffff0000
+#define GICD_INT_EN_SET_SGI 0x0000ffff
+#define GICD_ICFG_LEVEL_TRIGGER 0x55555555
+#define GICC_UNMASK_ALL_PRIORITY 0xff
+
+#define gicd_readl(OFFSET) readl(gbase + GIC_DISTRIBUTOR_OFFSET + (OFFSET))
+#define gicd_writel(VALUE, OFFSET) \
+       writel((VALUE), gbase + GIC_DISTRIBUTOR_OFFSET + (OFFSET))
+#define gicc_readl(OFFSET) readl(gbase + GIC_CPU_OFFSET + (OFFSET))
+#define gicc_writel(VALUE, OFFSET) \
+       writel((VALUE), gbase + GIC_CPU_OFFSET + (OFFSET))
+#define gich_readl(OFFSET) readl(gbase + GIC_INTERFACE_OFFSET + (OFFSET))
+#define gicv_readl(OFFSET) readl(gbase + GIC_VIRT_OFFSET + (OFFSET))
+#define ITLINES_MASK 0x1f
+#define ITLINES_SHIFT 5
+#define GIC_MAX_IRQ 1020
+#define SPI_INT_NUM_MIN 32
+#define MAX_IRQ 0xfffffffe
+#define DEBUG_IRQ_ENABLED 1
+#if DEBUG_IRQ_ENABLED
+#define DBG_IRQ printf
+#else
+#define DBG_IRQ(...)
+#endif
+
+static size_t max_irq = 0;
+static interrupt_handler_t *handlers[GIC_MAX_IRQ] = {NULL};
+static unsigned long irq_total = 0;
+static unsigned long irq_counts[GIC_MAX_IRQ] = {0};
+static uint32_t gbase = 0;
+
+/* TODO: This, hard-coded, or from dts? */
+static inline uint32_t gic_base(void)
+{
+       uint32_t base;
+       /* read the base address of the private peripheral space */
+       __asm__ __volatile__("mrc p15, 4, %r0, c15, c0, 0\n\t" : "=r"(base) : );
+       return base;
+}
+
+static void enable_gic(void)
+{
+       uint32_t gicd_ctlr, gicc_ctlr;
+
+       DBG_IRQ("  %s()\n", __FUNCTION__);
+       /* add GIC offset ref table 1-3 for interrupt distributor address */
+       gicd_ctlr = gicd_readl(GICD_CTLR);
+       gicc_ctlr = gicc_readl(GICC_CTLR);
+       gicd_writel(gicd_ctlr | GICD_CTLR_ENABLE, GICD_CTLR);
+       gicc_writel(gicc_ctlr | GICC_CTLR_ENABLE, GICC_CTLR);
+}
+
+static void disable_gic(void)
+{
+       uint32_t gicd_ctlr, gicc_ctlr;
+       DBG_IRQ("  %s()\n", __FUNCTION__);
+       /* add GIC offset ref table 1-3 for interrupt distributor address */
+       gicd_ctlr = gicd_readl(GICD_CTLR);
+       gicd_writel(gicd_ctlr & ~GICD_CTLR_ENABLE, GICD_CTLR);
+       gicc_ctlr = gicc_readl(GICC_CTLR);
+       gicc_writel(gicc_ctlr & ~GICC_CTLR_ENABLE, GICC_CTLR);
+}
+
+static void enable_irq_id(unsigned int id)
+{
+       DBG_IRQ("  %s()\n", __FUNCTION__);
+       uint32_t grp = id >> ITLINES_SHIFT;
+       uint32_t grp_bit = 1 << (id & ITLINES_MASK);
+       gicd_writel(grp_bit, GICD_ISENABLERn + grp * sizeof(uint32_t));
+       gicd_writel(GICD_ITARGET_ALL, GICD_ITARGETSRn + id / 4 * 4);
+}
+
+static void disable_irq_id(unsigned int id)
+{
+       DBG_IRQ("  %s()\n", __FUNCTION__);
+       uint32_t grp = id >> ITLINES_SHIFT;
+       uint32_t grp_bit = 1 << (id & ITLINES_MASK);
+       gicd_writel(grp_bit, GICD_ICENABLERn + grp * sizeof(uint32_t));
+}
+
+static int gic_probe(void)
+{
+       int i;
+       gbase = gic_base();
+       DBG_IRQ("gic_probe GIC base = 0x%x, magicd=0x%x\n",
+               gbase, gicd_readl(GICD_IIDR));
+       enable_gic();
+
+       if (gicd_readl(GICD_IIDR) != GIC_DISTRIBUTOR_IMPLEMENTER_MAGIC &&
+           gicc_readl(GICC_IIDR) != GIC_CPU_IMPLEMENTER_MAGIC &&
+           gicv_readl(GICV_IIDR) != GIC_VIRT_CPU_IMPLEMENTER_MAGIC)
+       {
+               printf("error: magic check \n");
+               return 0;
+       }
+       /* GIC supports up to 1020 lines */
+       max_irq = (((gicd_readl(GICD_TYPER) & ITLINES_MASK) + 1) * 32) - 1;
+       if (max_irq > GIC_MAX_IRQ)
+               max_irq = GIC_MAX_IRQ;
+       /* set all lines to be level triggered N-N */
+       for (i = 32; i < max_irq; i += 16)
+               gicd_writel(GICD_ICFG_LEVEL_TRIGGER, GICD_ICFGRn + i / 4);
+
+       DBG_IRQ("max_irq = 0x%x, typer=0x%x, config=0x%x, maxirq=0x%x\n", max_irq,
+               (gicd_readl(GICD_TYPER) & ITLINES_MASK) + 1,
+               gicd_readl(GICD_ICFGRn + 0x8),
+               ((gicd_readl(GICD_TYPER) & ITLINES_MASK) + 1) * 0x20);
+
+       /* Set priority on all interrupts. */
+       for (i = 0; i < max_irq; i += 4)
+               gicd_writel(GICD_INT_DEF_PRI_X4, GICD_IPRIORITYRn + i);
+
+       /* Deactivate and disable all SPIs. */
+       for (i = 32; i < max_irq; i += 32) {
+               gicd_writel(GICD_INT_EN_CLR_X32, GICD_ICACTIVERn + i / 8);
+               gicd_writel(GICD_INT_EN_CLR_X32, GICD_ICENABLERn + i / 8);
+       }
+       gicd_writel(GICD_INT_EN_CLR_X32, GICD_ICACTIVERn);
+       gicd_writel(GICD_INT_EN_CLR_PPI, GICD_ICENABLERn);
+       gicd_writel(GICD_INT_EN_SET_SGI, GICD_ISENABLERn);
+       /* unmask all priority */
+       gicc_writel(GICC_UNMASK_ALL_PRIORITY, GICC_PMRn);
+
+       return 0;
+}
+
+void irq_free_handler (int irq);
+static void gic_shutdown(void)
+{
+       DBG_IRQ("  %s()\n", __FUNCTION__);
+       int i;
+       for (i = 0; i < max_irq; i++)
+       {
+               irq_free_handler(i);
+       }
+       disable_gic();
+}
+
+int arch_interrupt_init_early(void)
+{
+       DBG_IRQ("  %s()\n", __FUNCTION__);
+       return 0;
+}
+
+int arch_interrupt_init(void)
+{
+       int i;
+       for (i = 0; i < GIC_MAX_IRQ; i++)
+       {
+               handlers[i] = NULL;
+               irq_counts[i] = 0;
+       }
+       DBG_IRQ("  %s()\n", __FUNCTION__);
+       return gic_probe();
+}
+
+int arch_interrupt_fini(void)
+{
+       DBG_IRQ("  %s()\n", __FUNCTION__);
+       gic_shutdown();
+       return 0;
+}
+
+int interrupt_init (void)
+{
+       /*
+        * setup up stacks if necessary
+        */
+       IRQ_STACK_START = gd->irq_sp + 8;
+       IRQ_STACK_START_IN = gd->irq_sp + 8;
+
+       DBG_IRQ("  %s()\n", __FUNCTION__);
+       return arch_interrupt_init();
+}
+
+int global_interrupts_enabled (void)
+{
+    unsigned long cpsr;
+       __asm__ __volatile__("mrs %0, cpsr\n"
+                       : "=r" (cpsr)
+                       :
+                       : "memory");
+
+       return (cpsr & 0x80) == 0;
+}
+
+void enable_interrupts (void)
+{
+    unsigned long cpsr;
+       __asm__ __volatile__("mrs %0, cpsr\n"
+                       "bic %0, %0, #0x1c0\n"
+                       "msr cpsr_c, %0"
+                       : "=r" (cpsr)
+                       :
+                       : "memory");
+
+       DBG_IRQ("  %s()\n", __FUNCTION__);
+       return;
+}
+
+int disable_interrupts (void)
+{
+       unsigned long cpsr, temp;
+       __asm__ __volatile__("mrs %0, cpsr\n"
+                       "orr %1, %0, #0xc0\n"
+                       "msr cpsr_c, %1"
+                       : "=r" (cpsr), "=r" (temp)
+                       :
+                       : "memory");
+       DBG_IRQ("  %s()\n", __FUNCTION__);
+       return (cpsr & 0x80) == 0;
+}
+
+void irq_install_handler(int irq, interrupt_handler_t *handler, void *ctx)
+{
+       if (irq > max_irq) {
+               printf("irq %d out of range\n", irq);
+               return;
+       }
+       if (handlers[irq]) {
+               printf("irq %d already in use (%p)\n", irq, handlers[irq]);
+               return;
+       }
+       DBG_IRQ("registering handler for irq %d\n", irq);
+       handlers[irq] = handler;
+       enable_irq_id(irq);
+}
+
+void irq_free_handler (int irq)
+{
+       DBG_IRQ("  %s()\n", __FUNCTION__);
+       if (irq >= max_irq) {
+               printf("irq %d out of range\n", irq);
+               return;
+       }
+       if (handlers[irq]) {
+               handlers[irq] = NULL;
+               disable_irq_id(irq);
+       }
+}
+
+int do_irqinfo(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+       int i;
+       int enabled = global_interrupts_enabled();
+       printf("GIC base = 0x%x\n", gbase);
+       printf("interrupts %sabled\n", (enabled ? "en" : "dis"));
+       uint32_t grp_en = 0;
+       for (i = 0; i < max_irq; i++) {
+               if ((i & ITLINES_MASK) == 0)
+                       grp_en = gicd_readl(GICD_ISENABLERn +
+                                       (i >> ITLINES_SHIFT) * sizeof(uint32_t));
+               int irq_enabled = grp_en & (1 << (i & ITLINES_MASK));
+               if (!irq_enabled)
+                       continue;
+               printf("% 2i (% 3s): %lu\n", i,
+                      (irq_enabled ? "on" : "off"), irq_counts[i]);
+       }
+       printf("total: %lu\n", irq_total);
+       return 0;
+}
+
+void do_irq(struct pt_regs *pt_regs)
+{
+       uint32_t irqstat = 0, irqnr = 0;
+
+       if (irq_total < MAX_IRQ)
+               irq_total++;
+       irqstat = gicc_readl(GICC_IAR);
+       irqnr = irqstat & GICC_IAR_INT_ID_MASK;
+
+       if (irqnr > SPI_INT_NUM_MIN && irqnr < GIC_MAX_IRQ) {
+               gicc_writel(irqnr, GICC_EOIR);
+               if (irq_counts[irqnr] < MAX_IRQ)
+                       irq_counts[irqnr]++;
+               if (handlers[irqnr])
+               {
+                       handlers[irqnr](NULL);
+               }
+       }
+}
+                                         
--- a/board/aspeed/evb_ast2600/ast-irq.h	1970-01-01 08:00:00.000000000 +0800
+++ b/board/aspeed/evb_ast2600/ast-irq.h	2020-06-18 17:34:37.392096882 +0800
@@ -0,0 +1,8 @@
+#ifndef _AST_IRQ_H_
+#define _AST_IRQ_H_
+
+int release_irq(int irq);
+int arch_interrupt_init_early(void);
+
+#endif
+
--- a/board/aspeed/evb_ast2600/ast-timer.c	1970-01-01 08:00:00.000000000 +0800
+++ b/board/aspeed/evb_ast2600/ast-timer.c	2020-06-18 17:34:37.392096882 +0800
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2019 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <common.h>
+#include <asm/io.h>
+
+static const int timer_irqs[] = {48, 49, 50, 51, 52, 53, 54, 55};
+#define AST_TIMER_BASE 0x1e782000
+/* offsets from AST_TIMER_BASE for each timer */
+static const uint32_t timer_bases[] = {0, 0x10, 0x20, 0x40,
+                                      0x50, 0x60, 0x70, 0x80};
+#define TIMER_1MHZ_CLK_COUNT 1000000u
+#define TIMER_ENABLE 1
+#define TIMER_1MHZ_CLK_SEL 2
+#define TIMER_ENABLE_IRQ 4
+#define TIMER_RESET_BY_WDT 8
+#define TIMER_CONTROL 0x30
+#define TIMER_RELOAD 0x04
+#define TIMER_CONTROL_CLEAR 0x3c
+
+void timer_disable(int n)
+{
+       if (n < 0 || n > 7) {
+               return;
+       }
+       uint32_t tctrl = 0xf << (n * 4);
+       writel(tctrl, AST_TIMER_BASE + TIMER_CONTROL_CLEAR);
+}
+
+void timer_enable(int n, uint32_t freq, interrupt_handler_t *handler)
+{
+       if (n < 0 || n > 7) {
+               return;
+       }
+       if (!freq)
+               return;
+
+       timer_disable(n);
+
+       uint32_t v = TIMER_1MHZ_CLK_COUNT / freq;
+       writel(v, AST_TIMER_BASE + timer_bases[n] + TIMER_RELOAD);
+
+       uint32_t tctrl = (
+                               TIMER_ENABLE |
+                               TIMER_1MHZ_CLK_SEL |
+                               TIMER_RESET_BY_WDT) << (n * 4);
+
+       if (handler) {
+               irq_install_handler(timer_irqs[n], handler, NULL);
+               tctrl |= (TIMER_ENABLE_IRQ << (n * 4));
+       }
+       writel(tctrl, AST_TIMER_BASE + TIMER_CONTROL);
+}
+
--- a/arch/arm/lib/vectors.S	2020-08-13 00:30:11.151700958 -0400
+++ b/arch/arm/lib/vectors.S	2020-08-13 20:31:20.146238450 -0400
@@ -14,6 +14,7 @@
 
 #include <config.h>
 
+#define CONFIG_USE_IRQ
 /*
  * A macro to allow insertion of an ARM exception vector either
  * for the non-boot0 case or by a boot0-header.
@@ -144,6 +145,16 @@
 	b	1b			/* hang and never return */
 
 #else	/* !CONFIG_SPL_BUILD */
+#ifdef CONFIG_USE_IRQ
+/* IRQ stack memory (calculated at run-time) */
+.globl IRQ_STACK_START
+IRQ_STACK_START:
+       .word   0x0badc0de
+/* IRQ stack memory (calculated at run-time) */
+.globl FIQ_STACK_START
+FIQ_STACK_START:
+       .word 0x0badc0de
+#endif
 
 /* IRQ stack memory (calculated at run-time) + 8 bytes */
 .globl IRQ_STACK_START_IN
@@ -279,6 +290,22 @@
 
 
 	.align	5
+#ifdef CONFIG_USE_IRQ
+irq:
+       get_irq_stack
+       irq_save_user_regs
+       bl      do_irq
+       irq_restore_user_regs
+       .align  5
+fiq:
+       get_fiq_stack
+       /* someone ought to write a more effective fiq_save_user_regs */
+       irq_save_user_regs
+       bl      do_fiq
+       irq_restore_user_regs
+
+        .align  5
+#else
 irq:
 	get_bad_stack
 	bad_save_user_regs
@@ -291,3 +318,4 @@
 	bl	do_fiq
 
 #endif	/* CONFIG_SPL_BUILD */
+#endif  /* CONFIG_SPL_BUILD */
--- a/arch/arm/lib/interrupts.c	2020-08-13 00:30:11.387704325 -0400
+++ b/arch/arm/lib/interrupts.c	2020-08-13 20:24:16.077663759 -0400
@@ -25,6 +25,7 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
+int interrupt_init (void) __attribute__((weak));
 int interrupt_init (void)
 {
 	/*
@@ -35,10 +36,13 @@
 	return 0;
 }
 
+void enable_interrupts (void) __attribute__((weak));
 void enable_interrupts (void)
 {
 	return;
 }
+
+int disable_interrupts (void) __attribute__((weak));
 int disable_interrupts (void)
 {
 	return 0;
@@ -189,6 +193,7 @@
 	bad_mode ();
 }
 
+void do_irq (struct pt_regs *pt_regs) __attribute__((weak));
 void do_irq (struct pt_regs *pt_regs)
 {
 	efi_restore_gd();
--- a/board/aspeed/evb_ast2600/Makefile	2020-08-13 00:24:16.546641359 -0400
+++ b/board/aspeed/evb_ast2600/Makefile	2020-08-13 20:39:41.927712393 -0400
@@ -1 +1 @@
-obj-y += evb_ast2600.o
+obj-y += evb_ast2600.o vc_ast2600.o ast-irq.o ast-timer.o
